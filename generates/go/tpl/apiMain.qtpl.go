/*
 * Copyright (c) 2022. Author: Ruslan Bikchentaev. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 * Першій пріватний програміст.
 */

// Code generated by qtc from "apiMain.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

//line apiMain.qtpl:2
package tpl

//line apiMain.qtpl:2
import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

//line apiMain.qtpl:2
var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

//line apiMain.qtpl:2
func (a *ApiMain) StreamCreateMain(qw422016 *qt422016.Writer, packageName string, routes []string) {
//line apiMain.qtpl:2
	qw422016.N().S(`
// Code generated by httpgo-gen-go. DO NOT EDIT.
// versions:
// 	httpgo v1.2.6
// source: `)
//line apiMain.qtpl:6
	qw422016.E().S(a.Name)
//line apiMain.qtpl:6
	qw422016.N().S(` apiRoute
package main

import (
	"flag"
	"fmt"
	"net"
	"sort"
`)
//line apiMain.qtpl:14
	switch a.auth {
//line apiMain.qtpl:15
	case JWT:
//line apiMain.qtpl:15
		qw422016.N().S(`
			},
		},
	`)
//line apiMain.qtpl:18
	case OAuth2:
//line apiMain.qtpl:18
		qw422016.N().S(`
	"os"
	"go/types"
	`)
//line apiMain.qtpl:21
	}
//line apiMain.qtpl:21
	qw422016.N().S(`
	"path"
	"time"

	"github.com/valyala/fasthttp"
	"golang.org/x/net/context"

	"github.com/ruslanBik4/dbEngine/dbEngine"
	"github.com/ruslanBik4/dbEngine/dbEngine/psql"
	httpgo "github.com/ruslanBik4/httpgo/httpGo"
	"github.com/ruslanBik4/httpgo/views/templates/layouts"
	"github.com/ruslanBik4/httpgo/views/templates/pages"
	"github.com/ruslanBik4/httpgo/views"
	"github.com/ruslanBik4/httpgo/auth"
	"github.com/ruslanBik4/httpgo/apis"
	"github.com/ruslanBik4/httpgo/apis/crud"
	"github.com/ruslanBik4/logs"
	api "`)
//line apiMain.qtpl:38
	qw422016.E().S(packageName)
//line apiMain.qtpl:38
	qw422016.N().S(`/api"
)


const ShowVersion = "/api/version()"
// names of system environment variables
const (
	CFG_PATH    = "configPath"
	WEB_PATH    = "webPath"
	SYSTEM_PATH = "systemPath"
)


var (
	routes = apis.ApiRoutes{
		ShowVersion: {
			Fnc:  HandleVersion,
			Desc: "view version server",
		},
		"/": &apis.ApiRoute{
			Desc: "default endpoint",
			Fnc: HandleIndex,
		},
		"/show/forms/": &apis.ApiRoute{
			Desc: "show form",
			Fnc: func(ctx *fasthttp.RequestCtx) (interface{}, error) {

				switch ctx.UserValue(crud.ParamsName.Name).(string) {
				case "signin":
					views.RenderSignForm(ctx, "")
					return nil, nil
				default:

					return `)
//line apiMain.qtpl:38
	qw422016.N().S("`")
//line apiMain.qtpl:38
	qw422016.N().S(`
				<form action="/auth" target="_modal">
				<select name="type_oauth">
				<option value=2> Github </option>
				</select>
				<input type=submit >
				</form>`)
//line apiMain.qtpl:38
	qw422016.N().S("`")
//line apiMain.qtpl:38
	qw422016.N().S(`, nil
				}
			},
			Params: []apis.InParam{
				crud.ParamsName,
			},
		},
	`)
//line apiMain.qtpl:84
	switch a.auth {
//line apiMain.qtpl:85
	case JWT:
//line apiMain.qtpl:85
		qw422016.N().S(`
	`)
//line apiMain.qtpl:86
	case OAuth2:
//line apiMain.qtpl:86
		qw422016.N().S(`
		"/callback": &apis.ApiRoute{
			Desc: "default endpoint",
			Fnc: func(ctx *fasthttp.RequestCtx) (interface{}, error) {
				s := ctx.Request.URI().QueryArgs().String()
				logs.StatusLog(s)
				a, ok := ctx.UserValue(apis.AuthManager).(*auth.OAuth2)
				if ok {
					token, err := a.Exchange(ctx, string(ctx.Request.URI().QueryArgs().Peek("code")))
					if err != nil {
						return nil, err
					}

					return token.AccessToken, nil
				}

				return s, nil
			},
			// FncAuth: auth.Basic,
		},
		"/auth": &apis.ApiRoute{
			Desc: "*auth* endpoint",
			Fnc: func(ctx *fasthttp.RequestCtx) (interface{}, error) {
				a, ok := ctx.UserValue("auth").(*auth.OAuth2)
				if ok {
					err := a.DoAuth(ctx, auth.AuthServer(ctx.UserValue("type_oauth").(uint8)), "read")
					if err != nil {
						return nil, err
					}
				}
				return nil, nil
			},
			Params: []apis.InParam{
				{
					Name:              "type_oauth",
					Desc:              "",
					Req:               true,
					PartReq:           nil,
					Type:              apis.NewTypeInParam(types.Uint8),
					DefValue:          nil,
					IncompatibleWiths: nil,
					TestValue:         "",
				},
			},
        },
	`)
//line apiMain.qtpl:131
	}
//line apiMain.qtpl:131
	qw422016.N().S(`
	}
	fPort     = flag.String("port", ":443", "host address to listen on")
	fPortRdr  = flag.String("port_redirect", ":80", "redirect another proto")
	fNoSecure = flag.Bool("insecure", true, "flag to force https")
	fSystem   = flag.String("path", "./", "path to system files")
	fCfgPath  = flag.String("config_path", "cfg", "path to cfg files")
	fWeb      = flag.String("web", "./", "path to web files")
)

var httpServer *httpgo.HttpGo

func init() {
	flag.Parse()
	listener, err := net.Listen("tcp", *fPort)
	if err != nil {
		// port is occupied - work serve unpassable
		logs.Fatal(err)
	}

	ctxApis := apis.NewCtxApis(0)

	ctxApis.AddValue(CFG_PATH, *fCfgPath)
	ctxApis.AddValue(SYSTEM_PATH, *fSystem)
	ctxApis.AddValue(WEB_PATH, *fWeb)
	DB := getDB(ctxApis)
	if DB == nil {
		panic("wrong DB setting or not found DB")
	}

	ctxApis.AddValue(apis.Database, DB)
	`)
//line apiMain.qtpl:162
	switch a.auth {
//line apiMain.qtpl:163
	case JWT:
//line apiMain.qtpl:163
		qw422016.N().S(`
	authBearer := &auth.AuthBearer{}
	`)
//line apiMain.qtpl:165
	case OAuth2:
//line apiMain.qtpl:165
		qw422016.N().S(`
	authBearer := auth.NewOAuth2(
		os.Getenv("client_id"),
		os.Getenv("client_secret"),
		"/callback",
	)
	`)
//line apiMain.qtpl:171
	}
//line apiMain.qtpl:171
	qw422016.N().S(`
	ctxApis.AddValue(apis.AuthManager, authBearer)

	a := apis.NewApis(ctxApis, initMapRoutes(), authBearer)
	badRoutings := a.AddRoutes(routes)
	if len(badRoutings) > 0 {
		logs.ErrorLog(apis.ErrRouteForbidden, badRoutings)
	}

	cfg, err := httpgo.NewCfgHttp(path.Join(*fSystem, *fCfgPath, "httpgo.yml"))
	if err != nil || cfg == nil {
		// not work without correct config
		logs.ErrorLog(err, "%v or nil cfg (%v), use default", cfg)
		cfg = &httpgo.CfgHttp{
			AccessConf: &httpgo.AccessConf{
				ChkConn:    false,
				AllowIP:    nil,
				DenyIP:     nil,
				Mess:       "",
				AllowRoute: nil,
				DenyRoute:  nil,
			},
			Domains:    nil,
			KillSignal: 0,
			Server:     &fasthttp.Server{},
		}
	}

	httpServer = httpgo.NewHttpgo(cfg, listener, a)

}
// version
var (
	Version string
	Build   string
	Branch  string
)

func main() {
	title, err := HandleVersion(nil)

	t := "https"
	if *fNoSecure {
		t = "http"
	}

	logs.StatusLog("%s starting %s on %s://localhost%s", title, time.Now(), t, *fPort)

	defer func() {
		errRec := recover()
		if err, ok := errRec.(error); ok {
			logs.ErrorLog(err)
		}
	}()

	err = httpServer.Run(
		!(*fNoSecure),
		path.Join(*fSystem, *fCfgPath, "server.crt"),
		path.Join(*fSystem, *fCfgPath, "server.key"))
	if err != nil {
		logs.ErrorLog(err)
	} else {
		logs.StatusLog("Server https correct shutdown at %v", time.Now())
	}
}


// HandleVersion show status httpgo
// @/api/version/
func HandleVersion(ctx *fasthttp.RequestCtx) (interface{}, error) {
	return fmt.Sprintf("`)
//line apiMain.qtpl:241
	qw422016.E().S(a.Name)
//line apiMain.qtpl:241
	qw422016.N().S(` (%s) Version: %s, Build Time: %s", Branch, Version, Build), nil
}

func HandleIndex(ctx *fasthttp.RequestCtx) (interface{}, error) {

	content := []byte(`)
//line apiMain.qtpl:241
	qw422016.N().S("`")
//line apiMain.qtpl:241
	qw422016.N().S(`
	`)
//line apiMain.qtpl:247
	switch a.auth {
//line apiMain.qtpl:248
	case JWT:
//line apiMain.qtpl:248
		qw422016.N().S(`
	`)
//line apiMain.qtpl:249
	case OAuth2:
//line apiMain.qtpl:249
		qw422016.N().S(`
				<html>
				<form action "/auth">
				<select name="type_oauth">
				<option value=2> Github </option>
				</select>
				</form>
    `)
//line apiMain.qtpl:256
	}
//line apiMain.qtpl:256
	qw422016.N().S(`
    `)
//line apiMain.qtpl:256
	qw422016.N().S("`")
//line apiMain.qtpl:256
	qw422016.N().S(`)

    body := &pages.IndexPageBody{
    		Name: nil,
    		Pass: nil,
    		TopMenu: []layouts.ItemMenu{
    			{Link: "/swagger.io", Label: "API Rest Docs", Target: "_blank"},
    			{Link: "#", Label: "Tables"},
    			{Link: "#", Label: "Custom forms"},
    		},
    		Catalog: nil,
    		HeadHTML: &layouts.HeadHTMLPage{
    			Title:      "`)
//line apiMain.qtpl:269
	qw422016.E().S(a.Name)
//line apiMain.qtpl:269
	qw422016.N().S(`",
    			Language:   "eng",
    			Charset:    "",
    			LinkStyles: nil,
    			MetaTags:   nil,
    			Scripts:    nil,
    		},
    		Title:   "Index page",
    		Content: content,
    	}
	menuViews := layouts.Menu{}
	DB, ok := ctx.UserValue(apis.Database).(*dbEngine.DB)
	if !ok {
		logs.StatusLog(DB, ok)
	} else {
		names := make([]string, 0, len(DB.Tables))
		for name := range DB.Tables {
			names = append(names, name)
		}

		sort.Strings(names)
		for _, name := range names {
			menuViews = append(menuViews, layouts.ItemMenu{
				Link:   "/table/" + name + "/form",
				Label:  name,
				Title:  DB.Tables[name].Comment(),
				Target: "_modal",
			})
		}
	}
	body.TopMenu[1].Content = menuViews.RenderDropdownMenu()

    return nil, views.RenderTemplate(ctx, "index", body)
}

func initMapRoutes() apis.MapRoutes{
	mapRoutes := apis.NewMapRoutes()
`)
//line apiMain.qtpl:306
	for _, name := range routes {
//line apiMain.qtpl:306
		qw422016.N().S(`	if badRoutings := mapRoutes.AddRoutes(api.`)
//line apiMain.qtpl:307
		qw422016.N().S(name)
//line apiMain.qtpl:307
		qw422016.N().S(`); len(badRoutings) > 0 {
		logs.ErrorLog(apis.ErrRouteForbidden, badRoutings)
	}
`)
//line apiMain.qtpl:310
	}
//line apiMain.qtpl:310
	qw422016.N().S(`    return mapRoutes
}
func getDB(ctx context.Context) *dbEngine.DB {
	dbCfgPath := path.Join("cfg", "DB")
	cfgDB := dbEngine.CfgDB{
		Url:       "",
		GetSchema: &struct{}{},
		PathCfg:   &dbCfgPath,
	}

	conn := psql.NewConn(nil, nil, nil)
	DB, err := dbEngine.NewDB(context.WithValue(ctx, dbEngine.DB_SETTING, cfgDB), conn)
	if err != nil {
		logs.ErrorLog(err, "")
		return nil
	}

	return DB
}
`)
//line apiMain.qtpl:330
}

//line apiMain.qtpl:330
func (a *ApiMain) WriteCreateMain(qq422016 qtio422016.Writer, packageName string, routes []string) {
//line apiMain.qtpl:330
	qw422016 := qt422016.AcquireWriter(qq422016)
//line apiMain.qtpl:330
	a.StreamCreateMain(qw422016, packageName, routes)
//line apiMain.qtpl:330
	qt422016.ReleaseWriter(qw422016)
//line apiMain.qtpl:330
}

//line apiMain.qtpl:330
func (a *ApiMain) CreateMain(packageName string, routes []string) string {
//line apiMain.qtpl:330
	qb422016 := qt422016.AcquireByteBuffer()
//line apiMain.qtpl:330
	a.WriteCreateMain(qb422016, packageName, routes)
//line apiMain.qtpl:330
	qs422016 := string(qb422016.B)
//line apiMain.qtpl:330
	qt422016.ReleaseByteBuffer(qb422016)
//line apiMain.qtpl:330
	return qs422016
//line apiMain.qtpl:330
}

//line apiMain.qtpl:331
func (a *ApiMain) StreamCreateGoMod(qw422016 *qt422016.Writer, packageName string, routes []string) {
//line apiMain.qtpl:331
	qw422016.N().S(`
module `)
//line apiMain.qtpl:332
	qw422016.E().S(packageName)
//line apiMain.qtpl:332
	qw422016.N().S(`

go 1.18

replace `)
//line apiMain.qtpl:336
	qw422016.E().S(packageName)
//line apiMain.qtpl:336
	qw422016.N().S(`/api => ./

require (
	github.com/jackc/pgx/v4 v4.16.1
	github.com/pkg/errors v0.9.1
	github.com/ruslanBik4/dbEngine v1.1.39
	github.com/ruslanBik4/gotools v0.0.0-20220812070354-0ce3c9f73a6f
	github.com/ruslanBik4/httpgo v1.2.14
	github.com/ruslanBik4/logs v0.0.131
	github.com/valyala/fasthttp v1.37.0
	github.com/valyala/fastjson v1.6.3
	github.com/valyala/quicktemplate v1.7.0
)


`)
//line apiMain.qtpl:351
}

//line apiMain.qtpl:351
func (a *ApiMain) WriteCreateGoMod(qq422016 qtio422016.Writer, packageName string, routes []string) {
//line apiMain.qtpl:351
	qw422016 := qt422016.AcquireWriter(qq422016)
//line apiMain.qtpl:351
	a.StreamCreateGoMod(qw422016, packageName, routes)
//line apiMain.qtpl:351
	qt422016.ReleaseWriter(qw422016)
//line apiMain.qtpl:351
}

//line apiMain.qtpl:351
func (a *ApiMain) CreateGoMod(packageName string, routes []string) string {
//line apiMain.qtpl:351
	qb422016 := qt422016.AcquireByteBuffer()
//line apiMain.qtpl:351
	a.WriteCreateGoMod(qb422016, packageName, routes)
//line apiMain.qtpl:351
	qs422016 := string(qb422016.B)
//line apiMain.qtpl:351
	qt422016.ReleaseByteBuffer(qb422016)
//line apiMain.qtpl:351
	return qs422016
//line apiMain.qtpl:351
}
