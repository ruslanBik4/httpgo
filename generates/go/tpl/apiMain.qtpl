

{% code
type ApiMain struct {
    Name string
}

func NewApiMain(name string) *ApiMain {
    return &ApiMain{
    name,
    }
} 
%}
{% func (a *ApiMain) CreateMain(apiPath string, routes []string) %}
// Code generated by httpgo-gen-go. DO NOT EDIT.
// versions:
// 	httpgo v1.1.6
// source: %s %s
package main

import (
	"flag"
	"fmt"
	"net"
	"path"
	"time"

	"github.com/valyala/fasthttp"
	"golang.org/x/net/context"

	"github.com/ruslanBik4/dbEngine/dbEngine"
	"github.com/ruslanBik4/dbEngine/dbEngine/psql"
	httpgo "github.com/ruslanBik4/httpgo/httpGo"
	"github.com/ruslanBik4/httpgo/auth"
	"github.com/ruslanBik4/httpgo/apis"
	"github.com/ruslanBik4/logs"
	api "{%s apiPath %}"
)


const ShowVersion = "/api/version()"
// names of system environment variables
const (
	CFG_PATH    = "configPath"
	WEB_PATH    = "webPath"
	SYSTEM_PATH = "systemPath"
)


var (
	routes = apis.ApiRoutes{
		"/": &apis.ApiRoute{
			Desc: "default endpoint",
			Fnc:  nil,
			// FncAuth: auth.Basic,
		},
		ShowVersion: {
			Fnc:  HandleVersion,
			Desc: "view version server",
		},
		// "/test/": &apis.ApiRoute{
		// 	Desc:   "default endpoint",
		// 	Fnc:    HandleTest,
		// 	Method: apis.POST,
		// },
	}
	fPort     = flag.String("port", ":443", "host address to listen on")
	fPortRdr  = flag.String("port_redirect", ":80", "redirect anather proto")
	fNoSecure = flag.Bool("insecure", false, "flag to force https")
	fSystem   = flag.String("path", "./", "path to system files")
	fCfgPath  = flag.String("config_path", "cfg", "path to cfg files")
	fWeb      = flag.String("web", "./", "path to web files")
)

var httpServer *httpgo.HttpGo

func init() {
	flag.Parse()
	listener, err := net.Listen("tcp", *fPort)
	if err != nil {
		// port is occupied - work serve unpossable
		logs.Fatal(err)
	}

	ctxApis := apis.NewCtxApis(0)

	ctxApis.AddValue(CFG_PATH, *fCfgPath)
	ctxApis.AddValue(SYSTEM_PATH, *fSystem)
	ctxApis.AddValue(WEB_PATH, *fWeb)
	DB := getDB(ctxApis)
	if DB == nil {
		panic("wrong DB setting or not found DB")
	}

	ctxApis.AddValue("DB", DB)
	authBearer := &auth.AuthBearer{}
	ctxApis.AddValue("auth", authBearer)

	mapRoutes := new(apis.MapRoutes)
    {%- for _, name := range routes -%}

	if badRoutings := mapRoutes.AddRoutes(api.{%s= name %}); len(badRoutings) > 0 {
		logs.ErrorLog(apis.ErrRouteForbidden, badRoutings)
	}

    {%- endfor -%}
	a := apis.NewApis(ctxApis, *mapRoutes, authBearer)
	badRoutings := a.AddRoutes(routes)
	if len(badRoutings) > 0 {
		logs.ErrorLog(apis.ErrRouteForbidden, badRoutings)
	}

	cfg, err := httpgo.NewCfgHttp(path.Join(*fSystem, *fCfgPath, "httpgo.yml"))
	if err != nil || cfg == nil {
		// not work without correct config
		logs.Fatal(err, cfg)
	}

	httpServer = httpgo.NewHttpgo(cfg, listener, a)

}
// version
var (
	Version string
	Build   string
	Branch  string
)

// HandleLogServer show status httpgo
// @/api/version/
func HandleVersion(ctx *fasthttp.RequestCtx) (interface{}, error) {

	return fmt.Sprintf("{%s a.Name%} (%s) Version: %s, Build Time: %s", Branch, Version, Build), nil
}

func main() {
	title, err := HandleVersion(nil)

	t := "https"
	if *fNoSecure {
		t = "http"
	}

	logs.StatusLog("%s starting %s on port %s (%s)", title, time.Now(), *fPort, t)

	defer func() {
		errRec := recover()
		if err, ok := errRec.(error); ok {
			logs.ErrorLog(err)
		}
	}()

	err = httpServer.Run(
		!(*fNoSecure),
		path.Join(*fSystem, *fCfgPath, "server.crt"),
		path.Join(*fSystem, *fCfgPath, "server.key"))
	if err != nil {
		logs.ErrorLog(err)
	} else {
		logs.StatusLog("Server https correct shutdown at %v", time.Now())
	}
}


func getDB(ctx context.Context) *dbEngine.DB {
	dbCfgPath := path.Join("cfg", "DB")
	cfgDB := dbEngine.CfgDB{
		Url:       "",
		GetSchema: &struct{}{},
		PathCfg:   &dbCfgPath,
	}

	conn := psql.NewConn(nil, nil, nil)
	DB, err := dbEngine.NewDB(context.WithValue(ctx, dbEngine.DB_SETTING, cfgDB), conn)
	if err != nil {
		logs.ErrorLog(err, "")
		return nil
	}

	return DB
}
{% endfunc %}