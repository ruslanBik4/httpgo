
{% import (
    "fmt"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/iancoleman/strcase"

	"github.com/ruslanBik4/httpgo/apis"
	"github.com/ruslanBik4/dbEngine/dbEngine"
)
%}
  interface of endpoint
  // Code generated by httpgo-gen-go. DO NOT EDIT.
{% code
type EndpointTpl struct {
    apis.ApiRoute
    dbEngine.Table
}

func NewEndpointTpl(route apis.ApiRoute, table dbEngine.Table) *EndpointTpl {
    return &EndpointTpl{
        route,
        table,
    }
}
%}
{% stripspace %}
{% func paramName(name string) %}
{%s= cases.Title(language.English, cases.NoLower).String(strcase.ToCamel(name)) %}
{% endfunc %}
{% func (e *EndpointTpl) dtoName() %}
{%= paramName(e.Name()) %}Fields
{% endfunc %}

{% func (e *EndpointTpl) NameRoutes() %}
{%= paramName(e.Name()) %}Routes
{% endfunc %}

{% func (e *EndpointTpl) RequiredFields() %}
{% code
   isNext := false
 %}
{%- for _, col := range e.Table.Columns() -%}
       	{% if col.Primary() %}
       	  {% if isNext %},  {% endif %}
       	  "{%s col.Name() %}"
        {% endif %}
    {% endfor %}
{% endfunc %}

{% endstripspace %}

{% func (e *EndpointTpl) ApisFile() %}
type
    {%= e.dtoName() %} struct {
       {% for _, param := range e.Params %}{% collapsespace %}
       {%s= fmt.Sprintf("%-21s", paramName(param.Name)) %}
       {%- if t, ok := (param.Type).(apis.TypeInParam); ok && t.DTO != nil -%}
       {%s= fmt.Sprintf("%T", t.DTO) %}
       {% else %}
       {%s= param.Type.String() %}
       {% endif %}
{% endcollapsespace %}       `json:"{%s param.Name %}"`
       {% endfor %} Limit                int     `json:"id_photos"`
     }
// GetValue implement httpgo.RouteDTO interface
func (r *{%= e.dtoName() %}) ReadParams(ctx *fasthttp.RequestCtx) {
   {% for _, param := range e.Params %}
        r.{%s= paramName(param.Name) %}, _ = ctx.UserValue("{%s param.Name %}").({% stripspace %}
        {%- if t, ok := (param.Type).(apis.TypeInParam); ok && t.DTO != nil -%}
           {%s= fmt.Sprintf("%T", t.DTO) %}
          {%- else -%}
           {%s param.Type.String() %}
       {% endif %}
        {% endstripspace %})
   {% endfor %}
}
// GetValue implement httpgo.RouteDTO interface
func (r *{%= e.dtoName() %}) GetValue() interface{} {
	return r
}
// NewValue implement httpgo.RouteDTO interface
func (r *{%= e.dtoName() %}) NewValue() interface{} {
	return {%= e.dtoName() %}{}
}
// CheckParams implement CheckDTO interface, put each params into user value on context
func (r *{%= e.dtoName() %}) CheckParams(ctx *fasthttp.RequestCtx, badParams map[string]string) bool {
	val := fastjson.MustParseBytes(ctx.Request.Body())
	{%- for _, param := range e.Params -%}
	if val.Exists("{%s param.Name %}") {
		ctx.SetUserValue("{%s param.Name %}", r.{%= paramName(param.Name) %})
	}
	{%- endfor -%}
	return true
}
// RefColValue return referral of column
func (r *{%= e.dtoName() %}) RefColValue(name string) interface{}{
	switch name {
	{%- for _, param := range e.Params -%}
	case "{%s param.Name %}":
        return &r.{%s= paramName(param.Name) %}
	{%- endfor -%}
   	default:
		logs.ErrorLog(errors.Errorf("unknown column name '%s'", name))
		return nil
	}
}
// ColValue return value of column
func (r *{%= e.dtoName() %}) ColValue(name string) interface{}{
	switch name {
	{%- for _, param := range e.Params -%}
	case "{%s param.Name %}":
        return r.{%= paramName(param.Name) %}
	{%- endfor -%}
   	default:
		logs.ErrorLog(errors.Errorf("unknown column name '%s'", name))
		return nil
	}
}
// GetFields implement dbEngine.RowScanner interface
func (r *{%= e.dtoName() %}) GetFields(columns []dbEngine.Column) []interface{} {
	v := make([]interface{}, len(columns))
	for i, col := range columns {
		v[i] = r.RefColValue( col.Name() )
	}

	return v
}

// NewValue implement httpgo.RouteDTO interface
func (r *{%= e.dtoName() %}) SqlOptions(ctx *fasthttp.RequestCtx, isWhere bool) []dbEngine.BuildSqlOptions {
        args := make([]interface{}, 0, {%d len(e.Params) %})
        colNames := make([]string, 0, {%d len(e.Params) %})
        {% for _, param := range e.Params %}
            if v := ctx.UserValue( "{%s param.Name %}" ); v != nil {
                args = append(args, v)
                colNames = append(colNames, "{%s param.Name %}")
            }
        {% endfor %}

	res := []dbEngine.BuildSqlOptions{
		dbEngine.Args(args...),
	}
	if isWhere {
		res = append(res, dbEngine.WhereForSelect(colNames...) )
	} else {
		res = append(res, dbEngine.Columns(colNames...) )
	}

	if r.Limit > 0 {
		res = append(res, dbEngine.FetchOnlyRows(r.Limit))
	}

	return res
}
var
	{%= e.NameRoutes() %} = apis.ApiRoutes{
		"/table/{%s e.Table.Name() %}/get": {
			Fnc:    Handle{%= paramName(e.Name()) %}Get,
			Desc:   "get data of table '{%s e.Name() %}' ({%s e.Desc %})",
			DTO:    &{%= e.dtoName()%}{},
			Method: apis.GET,
			NeedAuth: true,
		},
		"/table/{%s e.Table.Name() %}/put": {
			Fnc:    Handle{%= paramName(e.Name()) %}Put,
			Desc:   "{%s e.Desc %}",
			DTO:    &{%= e.dtoName() %}{},
			Multipart: true,
			Method: apis.POST,
			NeedAuth: true,
			Params: []apis.InParam{
			        apis.ParamsGetFormActions,
			        {%- for _, param := range e.Params -%}
			        {% code col := e.Table.FindColumn(param.Name)
			                param.Req = !col.IsNullable() && !col.AutoIncrement() %}
 		            {%s= fmt.Sprintf("%g",param) %},
                    {%- endfor %}
            },
		},
		"/table/{%s e.Table.Name() %}/update": {
			Fnc:    Handle{%= paramName(e.Name()) %}Update,
			Desc:   "{%s e.Desc %}",
			DTO:    &{%= e.dtoName() %}{},
			Method: apis.POST,
			Multipart: true,
			NeedAuth: true,
			Params: []apis.InParam{
			        apis.ParamsGetFormActions,
			        {%- for _, param := range e.Params -%}
 			        {% code col := e.Table.FindColumn(param.Name)
 			                param.Req = col.Primary() %}
		            {%s= fmt.Sprintf("%g",param) %},
                    {%- endfor %}
            },
		},
		"/table/{%s e.Table.Name() %}/form": {
			Fnc:    Handle{%= paramName(e.Name()) %}Form,
			Desc:   "get form for insert/update data into '{%s e.Table.Name() %}' ({%s e.Desc %})",
			DTO:    &{%= e.dtoName() %}{},
			Method: apis.GET,
			NeedAuth: true,
			Params: append(apis.BasicParams, []apis.InParam{
			        apis.ParamsGetFormActions,
			        {%- for _, param := range e.Params -%}
			        {% code param.Req = false %}
 		            {%s= fmt.Sprintf("%g",param) %},
                    {%- endfor %}
            }...),
			WithCors: true,
		},
	}

func Get{%= paramName(e.Name()) %}Params(ctx *fasthttp.RequestCtx) (dbEngine.Table, *{%= e.dtoName() %}, error) {
    DB, ok := ctx.UserValue(apis.Database).(*dbEngine.DB)
    if !ok {
        return nil, nil, dbEngine.ErrDBNotFound
    }

    table, ok := DB.Tables["{%s e.Table.Name() %}"]
    if !ok {
        return nil, nil, dbEngine.ErrNotFoundTable{Table: "{%s e.Table.Name() %}"}
    }

    params, ok := ctx.UserValue(apis.JSONParams).(*{%= e.dtoName() %})
    if !ok {
        params = &{%= e.dtoName() %}{}
        params.ReadParams(ctx)
    }

    return table, params, nil
}

func Handle{%= paramName(e.Name()) %}Get(ctx *fasthttp.RequestCtx) (interface{}, error) {
    table, params, err := Get{%= paramName(e.Name()) %}Params(ctx)
    if err != nil {
        return nil, errors.Wrap(err, "Handle{%= paramName(e.Name()) %}Get")
    }

    res := make([]{%= e.dtoName() %}, 0)
    buf := &{%= e.dtoName() %}{}
    err = table.SelectAndScanEach(ctx,
        func() error {
            res = append(res, *buf)

            return nil
        },
        buf,
        params.SqlOptions(ctx, true)...
    )
    if err != nil {
        return nil, errors.Wrap(err, "Handle{%= paramName(e.Name()) %}Get")
    }

    if len(res) == 0 {
        ctx.SetStatusCode(fasthttp.StatusNoContent)
        return nil, nil
    }

    return res, nil
}

func Handle{%= paramName(e.Name()) %}Put(ctx *fasthttp.RequestCtx) (interface{}, error) {
    table, params, err := Get{%= paramName(e.Name()) %}Params(ctx)
    if err != nil {
        return nil, errors.Wrap(err, "Handle{%= paramName(e.Name()) %}Put")
    }

    id, err := table.Insert(ctx, params.SqlOptions(ctx, false)...)
    if err != nil {
        return crud.CreateErrResult(err)
    }

    return crud.RenderCreatedResult(ctx, id, bytes.NewBufferString(""), nil, "/table/{%s e.Table.Name() %}/put")
}

func Handle{%= paramName(e.Name()) %}Update(ctx *fasthttp.RequestCtx) (interface{}, error) {
    table, params, err := Get{%= paramName(e.Name()) %}Params(ctx)
    if err != nil {
        return nil, errors.Wrap(err, "Handle{%= paramName(e.Name()) %}Update")
    }

	badParams := make(map[string]string, 0)
	columns := table.Columns()
	priColumns := make([]string, 0)
    args := make([]interface{}, 0, len(columns))
    colSel := make([]string, 0, len(columns))
	buf := bytes.NewBufferString("")
    for _, col := range columns {
        name := col.Name()
        arg := ctx.UserValue(name)
        if col.Primary() {

			if arg == nil {
				badParams[name] = "required params"
                continue
			}
            if arg := ctx.UserValue("new." + name); arg != nil {
                colSel = append(colSel, name)
                args = append(args, arg)
                _, err := fmt.Fprintf(buf, " %v", arg)
                if err != nil {
                    return nil, err
                }
            }
            priColumns = append(priColumns, name)
            continue
        }
        if arg == nil {
            continue
        }

        crud.AddColumnAndValue(name, table, arg, args, colSel, buf, badParams)
    }

    for _, name := range priColumns {
        args = append(args, ctx.UserValue(name))
    }

    i, err := table.Update(ctx,
        dbEngine.ColumnsForSelect(colSel...),
        dbEngine.WhereForSelect(priColumns...),
        dbEngine.ArgsForSelect(args...),
    )
    if err != nil {
        return nil, err
    }

    if i <= 0 {
        logs.DebugLog(colSel, priColumns)
        logs.DebugLog(args)
        return map[string]string{"update": fmt.Sprintf("%d inserted for request %+v", i, params)}, apis.ErrWrongParamsList
    }

    return crud.RenderAcceptedResult(ctx, colSel, buf, "/table/{%s e.Table.Name() %}/update")
}

func Handle{%= paramName(e.Name()) %}Form(ctx *fasthttp.RequestCtx) (interface{}, error) {
    table, params, err := Get{%= paramName(e.Name()) %}Params(ctx)
    if err != nil {
        return nil, errors.Wrap(err, "Handle{%= paramName(e.Name()) %}Form")
    }

 		// we must copy colsTable into local array
 		f := forms.FormField{
 			Title:       "{%s e.Table.Comment() %}",
 			Action:      "/table/{%s e.Table.Name() %}/",
 			Method:      "POST",
 			Description: "",
 		}

	val := fastjson.MustParseBytes(ctx.Request.Body())
 	if val.Exists({%= e.RequiredFields() %}) {

        record := {%= e.dtoName() %}{}
        err = table.SelectOneAndScan(ctx,
            &record,
            params.SqlOptions(ctx, true)...
        )
		if err == pgx.ErrNoRows {
			return map[string]string{`{%= e.RequiredFields() %}`: err.Error()}, apis.ErrWrongParamsList
		}
        if err != nil {
            return nil, errors.Wrap(err, "")
        }
 			f.Action += "update"
   } else {
   			f.Action += "put"
   }


		colDecors := make([]*forms.ColumnDecor, 0)

		columns := table.Columns()

	priColumns := make([]string, 0)
   for _, col := range columns {
        name := col.Name()
        if col.Primary() {

		 /* 	if arg == nil {
				badParams[name] = "required params"
                continue
			}
          if arg := ctx.UserValue("new." + name); arg != nil {
                colSel = append(colSel, name)
                args = append(args, arg)
                _, err := fmt.Fprintf(buf, " %v", arg)
                if err != nil {
                    return nil, err
                }
            }
         */   priColumns = append(priColumns, name)
            continue
        }
				if !(col.AutoIncrement() || col.Name() == "id" ||
					strings.Contains(col.Comment(), " (read_only)")) {

					colDec := forms.NewColumnDecor(col, nil)
					colDec.IsDisabled = colDec.IsReadOnly && !(colDec.IsHidden)
					colDec.IsSlice = strings.HasPrefix(col.Type(), "_")
					colDec.Value = nil

					if col.Primary() {
						colDec.IsHidden = true
						colDec.InputType = "hidden"
					} else if col.Type() == "text" {
						colDec.InputType = "textarea"
					} else if col.Name() == "id_photos" {
						colDec.InputType = "attachment"
					} else if col.Name() == "memo" {
						colDec.InputType = "markdown"
					}
					colDecors = append(colDecors, colDec)
				}
    }


    		lang, ok := ctx.UserValue(apis.ParamsLang.Name).(string)
    		if ok {
    			colDecors = append(colDecors, &forms.ColumnDecor{
    				Column:      dbEngine.NewStringColumn("lang", "lang", true),
    				IsHidden:    true,
    				InputType:   "hidden",
    				PatternList: nil,
    				Value:       lang,
    			})
    		}

 		btnList := []forms.Button{
 			{ButtonType: "submit", Title: "Insert", Position: true},
 			{ButtonType: "reset", Title: "Clear", Position: false},
 		}

   		blocks := []forms.BlockColumns{
    			{
    				Buttons:     btnList,
    				Columns:     colDecors,
    				Id:          1,
    				Title:       "",
    				Description: "",
    			},
    		}

    		_, ok = ctx.UserValue(apis.ParamsHTML.Name).(bool)
    		if !ok {
    			views.WriteJSONHeaders(ctx)
    		}

    		if f.Description == "" {
    			f.Description = "Input data for " + table.Comment()
    		}
    		f.WriteRenderForm(
    			ctx.Response.BodyWriter(),
    			ok, // && isHtml,
    			blocks...)

    		return nil, nil

}
{% endfunc %}